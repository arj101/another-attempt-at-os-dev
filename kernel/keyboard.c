#pragma once
#include "./headers/keyboard.h"
#include "headers/print_utils.h"
#include "headers/utils.h"

char scan_code_to_char(int scan_code, u8 shift) {
  static char scan_codes[] = {
      0,    0,  '1',  '2',  '3',  '4', '5', '6',  '7', '8', '9', '0',
      '-', '=', 0x08, 0x09, 'q',  'w', 'e', 'r',  't', 'y', 'u', 'i',
      'o', 'p', '[',  ']',  0x0A, 0,   'a', 's',  'd', 'f', 'g', 'h',
      'j', 'k', 'l',  ';',  '\'', '`', 0,   '\\', 'z', 'x', 'c', 'v',
      'b', 'n', 'm',  ',',  '.',  '/', 0,   '*',  0,   ' ', 0};

  static char scan_codes_shift[] = {
      0,    0,  '!',  '@',  '#',  '$', '%', '^',  '&', '*', '(', ')',
      '_', '+', 0x08, 0x09, 'q',  'w', 'e', 'r',  't', 'y', 'u', 'i',
      'o', 'p', '{',  '}',  0x0A, 0,   'a', 's',  'd', 'f', 'g', 'h',
      'j', 'k', 'l',  ':',  '\"', '~', 0,   '|', 'z', 'x', 'c', 'v',
      'b', 'n', 'm',  '<',  '>',  '?', 0,   '*',  0,   ' ', 0};

  if (scan_code >= sizeof(scan_codes) / sizeof(scan_codes[0])) return 0;
  if (shift == 0) return scan_codes[scan_code];
  return scan_codes_shift[scan_code];
}
void clear_key_queue(struct KeyQueue* queue) {
  queue->start = 0;
  queue->length = 0;
}

u8 key_queue_isfull(struct KeyQueue* queue) {
  return queue->length >= KEYQUEUE_SIZE;
}

u8 key_queue_isempty(struct KeyQueue* queue) {
  return queue->length == 0;
}

void push_key_queue(struct KeyQueue* queue, char value) {
  if (key_queue_isfull(queue)) return;

  queue->queue[(queue->start + queue->length++) % KEYQUEUE_SIZE] = value;
}

char pop_key_queue(struct KeyQueue* queue) {
  if(key_queue_isempty(queue)) return '\0';

  queue->length--;
  char val =  queue->queue[queue->start++];
  queue->start %= KEYQUEUE_SIZE;

  return val;
}


struct Keyboard* init_ps2_keyboard() {
  ps2_keyboard.shift = 0;
  ps2_keyboard.ctrl = 0;
  ps2_keyboard.num_lock = 0;
  ps2_keyboard.scroll_lock = 0;
  ps2_keyboard.caps_lock = 0;
  ps2_keyboard.extended_mode = 0;
  ps2_keyboard.key_queue.start = 0;
  ps2_keyboard.key_queue.length = 0;
  for (u32 i = 0; i < KEYQUEUE_SIZE; i++) ps2_keyboard.key_queue.queue[i] = 0;

  return &ps2_keyboard;
}

void ps2_keyboard_int(u8 code) {
  char key = 0;

  switch (code) {
    case 0x2A:
    case 0x36:
      ps2_keyboard.shift = 1;
      break;

    case 0xAA:
    case 0xB6:
      ps2_keyboard.shift = 0;
      break;

    case 0x3A:
      ps2_keyboard.caps_lock = !ps2_keyboard.caps_lock;
      break;

    case 0x45:
      ps2_keyboard.num_lock = !ps2_keyboard.num_lock;
      break;

    case 0x1D:
      ps2_keyboard.ctrl = true;
      break;

    case 0x9D:
      ps2_keyboard.ctrl = false;
      break;

    case 0xE0:
      ps2_keyboard.extended_mode = true;
      break;

    case 0xC6:
      ps2_keyboard.scroll_lock = !ps2_keyboard.scroll_lock;
      break;

    case 0x48:
      if (ps2_keyboard.extended_mode) {
        key = 0x7;
        break;
      }

    case 0x50:
      if (ps2_keyboard.extended_mode) {
        key = 0x6;
        break;
      }

    case 0x4B:
      if (ps2_keyboard.extended_mode) {
        key = 0x5;
        break;
      }

    case 0x4D:
      if (ps2_keyboard.extended_mode) {
        key = 0x4;
        break;
      }

    default:
      // Check if key is a letter and apply shift/caps lock
      key = scan_code_to_char(code, ps2_keyboard.shift);
      if (key >= 'a' && key <= 'z') {
        if (ps2_keyboard.shift || ps2_keyboard.caps_lock) {
          key -= 32;
        }
      }
      // what does this even do? [generated by ChatGPT]
      // // Check if key is a number and apply num lock
      // else if (key >= '0' && key <= '9')
      // {
      //     // if (ps2_keyboard_state.num_lock)
      //     // {
      //     //     key = scan_code_to_char(scan_code + 0x47);
      //     // }
      // }
      break;
  }

  if (key != 0) {
      push_key_queue(&ps2_keyboard.key_queue, key);
    // push(&key_queue, key);
  }

  if (code != 0xE0 && ps2_keyboard.extended_mode)
    ps2_keyboard.extended_mode = false;
}
